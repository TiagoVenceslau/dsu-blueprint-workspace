

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>OpenDSU Blueprint Workspace dsu-blueprint/src/core/model/decorators.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">DSU Blueprint Workspace</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://github.com/TiagoVenceslau/dsu-blueprint-workspace.git"
                        >
                            Github
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-Cli.html">Cli</a></li><li><a href="module-Core.html">Core</a></li><li><a href="module-db-decorators.html">db-decorators</a></li><li><a href="module-decorator-validation.html">decorator-validation</a></li><li><a href="module-Filesystem.html">Filesystem</a></li><li><a href="module-ts-workspace.html">ts-workspace</a></li></ul><h3>Namespaces</h3><ul><li><a href="Cli.cli.html">cli</a></li><li><a href="cli.toolkit.html">toolkit</a></li><li><a href="Core.core.html">core</a></li><li><a href="core.model.html">model</a></li><li><a href="core.opendsu.html">opendsu</a></li><li><a href="core.opendsu.api.html">api</a></li><li><a href="core.repository.html">repository</a></li><li><a href="core.repository.cache.html">cache</a></li><li><a href="core.repository.registry.html">registry</a></li><li><a href="core.web.html">web</a></li><li><a href="db-decorators.model.html">model</a></li><li><a href="db-decorators.operations.html">operations</a></li><li><a href="db-decorators.repository.html">repository</a></li><li><a href="db-decorators.utils.html">utils</a></li><li><a href="db-decorators.validation.html">validation</a></li><li><a href="decorator-validation.utils.html">utils</a></li><li><a href="filesystem.constants.html">constants</a></li><li><a href="FileSystem.filesystem.html">filesystem</a></li><li><a href="filesystem.utils.html">utils</a></li><li><a href="logging.html">logging</a></li><li><a href="model.constants.html">constants</a></li><li><a href="Model.Decorators.html">Decorators</a></li><li><a href="model.decorators_.html">decorators</a></li><li><a href="Model.Model.html">Model</a></li><li><a href="operations.decorators.html">decorators</a></li><li><a href="repository.decorators.html">decorators</a></li><li><a href="ts-workspace.Hello.html">Hello</a></li><li><a href="utils.constants.html">constants</a></li><li><a href="utils.errors.html">errors</a></li><li><a href="utils.injectables.html">injectables</a></li><li><a href="utils.logging.html">logging</a></li><li><a href="validation.constants.html">constants</a></li><li><a href="validation.decorators.html">decorators</a></li></ul><h3>Classes</h3><ul><li><a href="core.model.ArrayDSU.html">ArrayDSU</a></li><li><a href="core.model.DbDsuBlueprint.html">DbDsuBlueprint</a></li><li><a href="core.model.DSUModel.html">DSUModel</a></li><li><a href="core.model.DSUModelRegistryImp.html">DSUModelRegistryImp</a></li><li><a href="core.model.SeedDSU.html">SeedDSU</a></li><li><a href="core.model.WalletDSU.html">WalletDSU</a></li><li><a href="core.opendsu.factory.DSUFactoryRegistry.html">DSUFactoryRegistry</a></li><li><a href="core.opendsu.factory.FactoryRegistryImp.html">FactoryRegistryImp</a></li><li><a href="core.opendsu.factory.KeySSIFactoryRegistry.html">KeySSIFactoryRegistry</a></li><li><a href="core.repository.cache.DSUCache.html">DSUCache</a></li><li><a href="core.repository.OpenDSURepository.html">OpenDSURepository</a></li><li><a href="core.repository.registry.DSUOperationRegistry.html">DSUOperationRegistry</a></li><li><a href="core.repository.registry.RepositoryRegistry.html">RepositoryRegistry</a></li><li><a href="core.web.WebServiceImp.html">WebServiceImp</a></li><li><a href="model.decorators.ModelErrorDefinition.html">ModelErrorDefinition</a></li><li><a href="model.Model_.html">Model</a></li><li><a href="Model.ModelRegistryManager.html">ModelRegistryManager</a></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="OpenDSURepository_OpenDSURepository.html">OpenDSURepository</a></li><li><a href="SyncronousLock.html">SyncronousLock</a></li><li><a href="validation.ValidatorRegistry.html">ValidatorRegistry</a></li><li><a href="WebServiceImp_WebServiceImp.html">WebServiceImp</a></li></ul><h3>Interfaces</h3><ul><li>BuilderRegistry.&lt;<a href="global.html#T">T</a>></li><li><a href="core.opendsu.api.AnchoringApi.html">AnchoringApi</a></li><li><a href="core.opendsu.api.AuthToken.html">AuthToken</a></li><li><a href="core.opendsu.api.BdnsApi.html">BdnsApi</a></li><li><a href="core.opendsu.api.BrickingApi.html">BrickingApi</a></li><li><a href="core.opendsu.api.CacheApi.html">CacheApi</a></li><li><a href="core.opendsu.api.ConfigApi.html">ConfigApi</a></li><li><a href="core.opendsu.api.constants.ConstantsApi.html">ConstantsApi</a></li><li><a href="core.opendsu.api.constants.EnvironmentTypes.html">EnvironmentTypes</a></li><li><a href="core.opendsu.api.ContractsApi.html">ContractsApi</a></li><li><a href="core.opendsu.api.CrypoApi.html">CrypoApi</a></li><li><a href="core.opendsu.api.crypto.JWT.html">JWT</a></li><li><a href="core.opendsu.api.db.DSUDatabase.html">DSUDatabase</a></li><li><a href="core.opendsu.api.DBApi.html">DBApi</a></li><li><a href="core.opendsu.api.DSUDid.html">DSUDid</a></li><li><a href="core.opendsu.api.DSUEnclave.html">DSUEnclave</a></li><li><a href="core.opendsu.api.DSUObservable.html">DSUObservable</a></li><li><a href="core.opendsu.api.DSUSecurityContext.html">DSUSecurityContext</a></li><li><a href="core.opendsu.api.DSUStorage.html">DSUStorage</a></li><li><a href="core.opendsu.api.enclave.ApiHubSecurityProxy.html">ApiHubSecurityProxy</a></li><li><a href="core.opendsu.api.enclave.HighSecurityProxy.html">HighSecurityProxy</a></li><li><a href="core.opendsu.api.EnclaveApi.html">EnclaveApi</a></li><li><a href="core.opendsu.api.ErrorApi.html">ErrorApi</a></li><li><a href="core.opendsu.api.HttpApi.html">HttpApi</a></li><li><a href="core.opendsu.api.KeySSI.html">KeySSI</a></li><li><a href="core.opendsu.api.keyssi.ArraySSI.html">ArraySSI</a></li><li><a href="core.opendsu.api.keyssi.ConstSSI.html">ConstSSI</a></li><li><a href="core.opendsu.api.keyssi.SeedSSI.html">SeedSSI</a></li><li><a href="core.opendsu.api.keyssi.sReadSSI.html">sReadSSI</a></li><li><a href="core.opendsu.api.keyssi.WalletSSI.html">WalletSSI</a></li><li><a href="core.opendsu.api.KeyssiApi.html">KeyssiApi</a></li><li><a href="core.opendsu.api.m2dsu.ErrMap.html">ErrMap</a></li><li><a href="core.opendsu.api.m2dsu.MessagePipe.html">MessagePipe</a></li><li><a href="core.opendsu.api.M2DsuApi.html">M2DsuApi</a></li><li><a href="core.opendsu.api.MappingEngine.html">MappingEngine</a></li><li><a href="core.opendsu.api.MessageQueueApi.html">MessageQueueApi</a></li><li><a href="core.opendsu.api.NotificationsApi.html">NotificationsApi</a></li><li><a href="core.opendsu.api.oauth.DecodedToken.html">DecodedToken</a></li><li><a href="core.opendsu.api.oauth.OIDC.html">OIDC</a></li><li><a href="core.opendsu.api.OAuthApi.html">OAuthApi</a></li><li><a href="core.opendsu.api.OAuthStorage.html">OAuthStorage</a></li><li><a href="core.opendsu.api.OpenDSUCache.html">OpenDSUCache</a></li><li><a href="core.opendsu.api.OpenDSUUtilsApi.html">OpenDSUUtilsApi</a></li><li><a href="core.opendsu.api.OpenDSUWorkersApi.html">OpenDSUWorkersApi</a></li><li><a href="core.opendsu.api.ResolverApi.html">ResolverApi</a></li><li><a href="core.opendsu.api.SecurityContextApi.html">SecurityContextApi</a></li><li><a href="core.opendsu.api.StorageApi.html">StorageApi</a></li><li><a href="core.opendsu.api.SystemApi.html">SystemApi</a></li><li><a href="core.opendsu.api.w3cdid.CryptographicSkillsApi.html">CryptographicSkillsApi</a></li><li><a href="core.opendsu.api.W3cDIDApi.html">W3cDIDApi</a></li><li><a href="core.opendsu.api.WorkerPool.html">WorkerPool</a></li><li><a href="core.opendsu.DSU.html">DSU</a></li><li><a href="core.opendsu.DSUFactory.html">DSUFactory</a></li><li><a href="core.opendsu.DSUHandler.html">DSUHandler</a></li><li><a href="core.opendsu.OpenDSU.html">OpenDSU</a></li><li><a href="core.opendsu.WalletDsu.html">WalletDsu</a></li><li><a href="core.web.WebService.html">WebService</a></li><li><a href="filesystem.utils.fs.html">fs</a></li><li><a href="filesystem.utils.path.html">path</a></li><li><a href="utils.BuilderRegistry.html">BuilderRegistry</a></li><li><a href="utils.IRegistry.html">IRegistry</a></li><li><a href="validation.IValidatorRegistry.html">IValidatorRegistry</a></li><li><a href="Validation.Validatable.html">Validatable</a></li></ul><h3>Global</h3><ul><li><a href="global.html#buildDSU">buildDSU</a></li><li><a href="global.html#construct">construct</a></li><li><a href="global.html#getAllProperties">getAllProperties</a></li><li><a href="global.html#hasErrors">hasErrors</a></li><li><a href="global.html#inject">inject</a></li><li><a href="global.html#prefixMethod">prefixMethod</a></li><li><a href="global.html#prefixMethodAsync">prefixMethodAsync</a></li><li><a href="global.html#suffixMethod">suffixMethod</a></li><li><a href="global.html#suffixMethodAsync">suffixMethodAsync</a></li><li><a href="global.html#updateDSU">updateDSU</a></li><li><a href="global.html#wrapMethod">wrapMethod</a></li><li><a href="global.html#wrapMethodAsync">wrapMethodAsync</a></li></ul></div><div class="category"><h2>Decorators</h2><h3>Global</h3><ul><li><a href="global.html#addFileFS">addFileFS</a></li><li><a href="global.html#addFolderFS">addFolderFS</a></li><li><a href="global.html#date">date</a></li><li><a href="global.html#DSUBlueprint">DSUBlueprint</a></li><li><a href="global.html#dsuFile">dsuFile</a></li><li><a href="global.html#dsuFS">dsuFS</a></li><li><a href="global.html#dsuRepository">dsuRepository</a></li><li><a href="global.html#email">email</a></li><li><a href="global.html#environment">environment</a></li><li><a href="global.html#fromURL">fromURL</a></li><li><a href="global.html#fromWeb">fromWeb</a></li><li><a href="global.html#getFsKey">getFsKey</a></li><li><a href="global.html#max">max</a></li><li><a href="global.html#maxlength">maxlength</a></li><li><a href="global.html#min">min</a></li><li><a href="global.html#minlength">minlength</a></li><li><a href="global.html#model">model</a></li><li><a href="global.html#mount">mount</a></li><li><a href="global.html#pattern">pattern</a></li><li><a href="global.html#required">required</a></li><li><a href="global.html#step">step</a></li><li><a href="global.html#type">type</a></li><li><a href="global.html#url">url</a></li><li><a href="global.html#wallet">wallet</a></li></ul></div><div class="category"><h2>Tests</h2><h3>Classes</h3><ul><li><a href="ArrayDSUModel.html">ArrayDSUModel</a></li><li><a href="BuildDsuBlueprint.html">BuildDsuBlueprint</a></li><li><a href="FSDSUModel.html">FSDSUModel</a></li><li><a href="IdDsuBlueprint.html">IdDsuBlueprint</a></li><li><a href="ParticipantDsuBlueprint.html">ParticipantDsuBlueprint</a></li><li><a href="SeedDSUBlueprint.html">SeedDSUBlueprint</a></li><li><a href="SSAppDsuBlueprint.html">SSAppDsuBlueprint</a></li><li><a href="SSAppWebDsuBlueprint.html">SSAppWebDsuBlueprint</a></li><li><a href="TestIdDsuBlueprint.html">TestIdDsuBlueprint</a></li></ul></div><div class="category"><h2>Validators</h2><h3>Classes</h3><ul><li><a href="DateValidator.html">DateValidator</a></li><li><a href="EmailValidator.html">EmailValidator</a></li><li><a href="MaxLengthValidator.html">MaxLengthValidator</a></li><li><a href="MaxValidator.html">MaxValidator</a></li><li><a href="MinLengthValidator.html">MinLengthValidator</a></li><li><a href="MinValidator.html">MinValidator</a></li><li><a href="PatternValidator.html">PatternValidator</a></li><li><a href="RequiredValidator.html">RequiredValidator</a></li><li><a href="StepValidator.html">StepValidator</a></li><li><a href="URLValidator.html">URLValidator</a></li><li><a href="Validator.html">Validator</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>dsu-blueprint/src/core/model/decorators.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {model} from "@tvenceslau/decorator-validation/lib";
import {DSU, DSUAnchoringOptions, DSUIOOptions} from "../opendsu/types";
import {DsuKeys, DSUOperationPhase} from "./constants";
import {DSUModel} from "./DSUModel";
import {getDSUOperationsRegistry, getRepoRegistry} from "../repository/registry";
import {
    DSUCache,
    DSUCallback,
    DSUClassCreationHandler,
    DSUCreationHandler,
    DSUCreationUpdateHandler,
    DSUEditingHandler,
    fromCache, handleKeyDerivation,
    OpenDSURepository,
    ReadCallback
} from "../repository";
import DBModel from "@tvenceslau/db-decorators/lib/model/DBModel";
import {
    all,
    criticalCallback,
    CriticalError,
    DBOperations,
    Err,
    ModelCallback,
    OperationKeys
} from "@tvenceslau/db-decorators/lib";
import {KeySSI, KeySSISpecificArgs, KeySSIType} from "../opendsu/apis/keyssi";
import {ConstantsApi, getKeySSIApi} from "../opendsu";
import {
    DSUPostProcess,
    getDSUFactoryRegistry,
    getKeySSIFactoryRegistry,
    KeySSIFactoryResponse
} from "../opendsu/factory";

/**
 * Builds the final DSU Reflection Key
 *
 * @function
 *
 * @param {string} key
 *
 * @return {string} the full key
 *
 * @memberOf core.model
 */
export const getDSUModelKey = (key: string) => DsuKeys.REFLECT + key;

/**
 * Metadata passed to {@link DSUClassCreationHandler}s
 *
 * @typedef DSUClassCreationMetadata
 * @memberOf core.model
 */
export type DSUClassCreationMetadata = {
    [indexer: string]: any;
    dsu: {
        operation: string[],
        phase: DSUOperationPhase,
        domain: string | undefined,
        keySSIType: KeySSIType,
        batchMode: boolean,
        specificKeyArgs: KeySSISpecificArgs | undefined,
        props: string[] | undefined
    }
    ,
}

/**
 * DSU Blueprint Decorator
 *
 * Defines a class as a DSU Blueprint, enabling:
 *  - Automatic CRUD operations, just by updating its corresponding {@link DSUModel} instance and running it through the appropriate {@link OpenDSURepository};
 *  - Automatic validations &amp;&amp; easily extendable for added validations;
 *  - Automatic serialization -> transmission -> deserialization;
 *  - Controlled accesses: Ability easily to add business logic at key points of any CRUD operations
 *
 * Supported {@link KeySSIType}s:
 *  - {@link KeySSIType.SEED}: Expects:
 *      - keySsiType: {@link KeySSIType.SEED};
 *      - specificKeyArgs: {@link SeedSSISpecificArgs} | undefined;
 *      - props: none
 *  - {@link KeySSIType.ARRAY}: Expects:
 *      - keySsiType: {@link KeySSIType.ARRAY};
 *      - specificKeyArgs: {@link ArraySSISpecificArgs} | undefined;
 *      - props: {string[] | undefined} array of property names in the value chain notation {@link getValueFromValueChain} {@link createObjectToValueChain} that will be resolved from the {@link DSUModel}'s content and used to pass as {@link KeySSI} generation Arguments. &lt;strong>Must resolve to strings&lt;/strong>
 *      - extra Key generation args {string[] | undefined} that are passed to the {@link OpenDSURepository}'s methods will be appended to the ones from the props and also used to generate the {@link KeySSI}
 *  - {@link KeySSIType.WALLET}: Expects:
 *      - keySsiType: {@link KeySSIType.WALLET};
 *      - specificKeyArgs: {@link WalletSSISpecificArgs} | undefined;
 *      - props: {string[] | undefined}: array of property names in the value chain notation {@link getValueFromValueChain} {@link createObjectToValueChain} that will be resolved from the {@link DSUModel}'s content and used to pass as {@link KeySSI} generation Arguments. &lt;strong>Must resolve to strings&lt;/strong>
 *      - extra Key generation args {string[] | undefined} that are passed to the {@link OpenDSURepository}'s methods will be appended to the ones from the props and also used to generate the {@link KeySSI}
 *      - One Supported decorator under the {@link ConstantsApi#CODE_FOLDER} property key (defaults to 'code'). Supported decorators are:
 *          - {@link fromWeb};
 *          - {@link fromCache};
 *          - {@link mount}
 *
 * {@link OpenDSURepository} {@link OperationKeys}'s this decorator acts on:
 *  - {@link OperationKeys.CREATE}: Creates the {@link DSUBlueprint}:
 *      - Gets the keySSI and the {@link DSUFactoryMethod}'s {@link DSUAnchoringOptions} from the {@link KeySSIFactoryRegistry};
 *      - Creates the {@link DSU} via the {@link DSUFactoryRegistry#build}
 *  - {@link OperationKeys.READ}:
 *  - {@link OperationKeys.UPDATE}:
 *  - {@link OperationKeys.DELETE}:
 *
 *  {@link DSUOperationPhase} phases this decorator acts on:
 *  - {@link DSUOperationPhase.CLASS}:
 *
 * @prop {string | undefined} [domain] the DSU domain. default to undefined. when undefined, its the repository that controls the domain;
 * @prop {KeySSIType} [keySSIType] the KeySSI type used to anchor the DSU
 * @prop {KeySSISpecificArgs | undefined} [specificKeyArgs]  OpenDSU related arguments, specific to each KeySSI implementation.
 * @prop {DSUAnchoringOptions | undefined} [options] defaults to undefined.
 * @prop {boolean} [batchMode] defaults to true. decides if batchMode is meant to be used for this DSU
 * @prop {string[]} [props] any object properties that must be passed to the KeySSI generation function (eg: for Array SSIs)
 *
 * @decorator DSUBlueprint
 *
 * @category Decorators
 *
 * @todo Because everything is declarative, the hash of the {@link DSUModel} class file string literal + the hash of the dsu-blueprint bundle file can be used stored as DSU metadata and serve as proof of authenticity in theory. I guess if we store this lib.
 */
export const DSUBlueprint = (domain: string | undefined = undefined, keySSIType: KeySSIType = KeySSIType.SEED, specificKeyArgs: KeySSISpecificArgs | undefined = undefined, options: DSUAnchoringOptions | undefined = undefined, batchMode: boolean = true, ...props: string[]) => (original: Function) => {
    getRepoRegistry().register(original.name);

    const createHandler: DSUClassCreationHandler = function&lt;T extends DSUModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, model: T, decorator: DSUClassCreationMetadata, ...keyGenArgs:  (string | DSUCallback&lt;T>)[]){
        const callback: DSUCallback&lt;T> = keyGenArgs.pop() as DSUCallback&lt;T>;
        if (!callback)
            throw new CriticalError(`Missing Callback`);

        const {domain, keySSIType, specificKeyArgs, props, batchMode} = decorator.dsu;

        const keyArgs = [...(props || []), ...keyGenArgs] as string[];

        getKeySSIFactoryRegistry().build(this, model, keySSIType, domain || this.fallbackDomain, specificKeyArgs, keyArgs, (err: Err, response?: KeySSIFactoryResponse) => {
            if (err || !response)
                return criticalCallback(err || new Error(`Missing KeySSI factory response`), callback);
            const {keySSI, options} = response;

            getDSUFactoryRegistry().build(keySSI, options || {}, (err, dsu) => {
                if (err || !dsu)
                    return criticalCallback(err || new Error(`No DSU received`), callback);

                const postProcess: DSUPostProcess | undefined = getDSUFactoryRegistry().get(keySSIType, true) as DSUPostProcess;
                if (!postProcess)
                    return callback(undefined, model, dsu, batchMode);

                postProcess(dsu, (err, dsu) => {
                    if (err || !dsu)
                        return criticalCallback(err || new Error(`Missing PostProcessed DSU`), callback);
                    callback(undefined, model, dsu, batchMode);
                });
            });
        });
    }

    const updateHandler: DSUCreationUpdateHandler = function&lt;T extends DSUModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, model: T, oldModel: T, dsuObj: DSU, decorator: any, callback: DSUCallback&lt;T>): void {
        const {batchMode} = decorator.dsu;

        if (batchMode)
            dsuObj.beginBatch();

        callback(undefined, model, dsuObj);

    }

    const metadata: DSUClassCreationMetadata = {
        dsu: {
            domain: domain,
            keySSIType: keySSIType,
            batchMode: batchMode,
            specificKeyArgs: specificKeyArgs,
            props: props &amp;&amp; props.length ? props : undefined,
            phase: DSUOperationPhase.CLASS,
            operation: [OperationKeys.CREATE],
        }
    }

    return model({}, (instance) => {
        Reflect.defineMetadata(
            getDSUModelKey(DsuKeys.CONSTRUCTOR),
            metadata,
            instance.constructor
        );
        getDSUOperationsRegistry().register(createHandler, OperationKeys.CREATE, DSUOperationPhase.CLASS, instance, DsuKeys.CONSTRUCTOR);
        getDSUOperationsRegistry().register(updateHandler, OperationKeys.UPDATE, DSUOperationPhase.CLASS, instance, DsuKeys.CONSTRUCTOR);
    })(original);
}

/**
 * Metadata passed to {@link DSUCreationHandler}s
 *
 * @typedef DSUCreationMetadata
 * @memberOf core.model
 */
export type DSUCreationMetadata = {
    [indexer: string]: any;

    operation: string[],
    phase: string,
    dsu: string
    derive: boolean | number,
    options: DSUIOOptions | undefined,
    dsuPath: string
    ,
}

/**
 *
 *
 * @typedef T extends DSUModel
 *
 * @param {{new: T}} dsu
 * @param {boolean | number} [derive] decides if the resulting mount uses the Seed or the Read (or how many times it derives the key)
 * @param {string} [mountPath] defines the mount path, overriding the property name;
 * @param {DSUIOOptions} [mountOptions] defines the mount path, overriding the property name;
 * @param {string[]} [modelArgs] optional model KeySSI generation params
 * @param {any[]} [args] optional KeySSI generation params
 *
 * @decorator dsu
 *
 * @category Decorators
 */
export function dsu&lt;T extends DSUModel>(dsu: {new(): T}, derive: boolean | number = false, mountPath?: string, mountOptions?: DSUIOOptions, modelArgs?: string[], ...args: any[]) {
    getRepoRegistry().register&lt;OpenDSURepository&lt;T>>(dsu);
    return (target: T, propertyKey: string) => {
        const dsuPath = mountPath ? mountPath : propertyKey;

        const metadata: DSUCreationMetadata = {
            phase: DSUOperationPhase.CREATION,
            operation: DBOperations.CREATE,
            dsu: target.constructor.name,
            derive: derive,
            dsuPath: dsuPath,
            options: mountOptions,
            modelArgs: modelArgs,
            args: args
        };

        Reflect.defineMetadata(
            getDSUModelKey(DsuKeys.DSU),
            metadata,
            target,
            propertyKey
        );

        fromCache&lt;T>(dsu, derive, dsuPath, mountOptions)(target, propertyKey);

        const createHandler: DSUCreationHandler = function&lt;T extends DSUModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, model: T, decorator: DSUCreationMetadata, ...keyGenArgs: (string | ModelCallback&lt;T>)[]): void {
            const callback: ModelCallback&lt;T> = keyGenArgs.pop() as ModelCallback&lt;T>;
            if (!callback)
                throw new CriticalError("Missing Callback");
            const {dsu} = decorator;

            const repo = getRepoRegistry().get&lt;OpenDSURepository&lt;T>>(dsu)
            if (!repo)
                return criticalCallback(new Error(`Cannot find ${model.constructor.name} repository`), callback);

            repo.create(model, dsuCache, ...keyGenArgs, (err: Err, newModel: T, dsu: DSU, keySSI: KeySSI) => {
                if (err)
                    return callback(err);
                callback(undefined, newModel, dsu, keySSI);
            });
        }

        getDSUOperationsRegistry().register(createHandler, OperationKeys.CREATE, DSUOperationPhase.CREATION, target, propertyKey);

        const updateHandler: DSUCreationUpdateHandler = function&lt;T extends DSUModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, model: T, oldModel: T, dsuObj: DSU, decorator: any, callback: DSUCallback&lt;T>): void {
            const {dsu, dsuPath} = decorator;

            const repo = getRepoRegistry().get&lt;OpenDSURepository&lt;T>>(dsu)
            if (!repo)
                return criticalCallback(new Error(`Cannot find ${model.constructor.name} repository`), callback);

            dsuObj.getSSIForMount(dsuPath, (err, keySSI) => {
                if (err || !keySSI)
                    return criticalCallback(err || new Error(`No KeySSI for specified mount`), callback);

                repo.update(keySSI, model, dsuCache, (err: Err, newModel: T, dsu: DSU, keySSI: KeySSI) => {
                    if (err)
                        return callback(err);
                    callback(undefined, newModel, dsu, keySSI);
                });
            });
        }

        getDSUOperationsRegistry().register(updateHandler, OperationKeys.UPDATE, DSUOperationPhase.CREATION, target, propertyKey);

        const readHandler: DSUEditingHandler = function&lt;T extends DSUModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, model: T | {}, dsuObj: DSU, decorator: any, callback: DSUCallback&lt;T> | ReadCallback): void {
            const {dsu, dsuPath, prop} = decorator;

            const repo = getRepoRegistry().get&lt;OpenDSURepository&lt;T>>(dsu)
            if (!repo)
                return criticalCallback(new Error(`Cannot find ${model.constructor.name} repository`), callback);

            dsuObj.getSSIForMount(dsuPath, (err, keySSI) => {
                if (err || !keySSI)
                    return criticalCallback(err || new Error(`No KeySSI for specified mount`), callback);

                repo.read(keySSI, (err: Err, newModel: T, dsu: DSU, keySSI: KeySSI) => {
                    if (err)
                        return callback(err);
                    // @ts-ignore
                    model[prop] = newModel;
                    callback(undefined, model as T, dsu, keySSI);
                });
            });
        }

        getDSUOperationsRegistry().register(readHandler, OperationKeys.READ, DSUOperationPhase.EDITING, target, propertyKey);

        const deleteHandler: DSUCreationUpdateHandler = function&lt;T extends DSUModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, model: T, oldModel: T, dsuObj: DSU, decorator: any, callback: DSUCallback&lt;T>): void {
            const {dsu, dsuPath} = decorator;

            const repo = getRepoRegistry().get&lt;OpenDSURepository&lt;T>>(dsu)
            if (!repo)
                return criticalCallback(new Error(`Cannot find ${model.constructor.name} repository`), callback);

            dsuObj.getSSIForMount(dsuPath, (err, keySSI) => {
                if (err || !keySSI)
                    return criticalCallback(err || new Error(`No KeySSI for specified mount`), callback);

                repo.delete(keySSI, (err: Err, newModel: T, dsu: DSU, keySSI: KeySSI) => {
                    if (err)
                        return callback(err);

                    dsuObj.unmount(dsuPath, (err) => {
                        if (err)
                            return callback(err);
                        callback(undefined, newModel, dsu, keySSI);
                    });
                });
            });
        }

        getDSUOperationsRegistry().register(deleteHandler, OperationKeys.DELETE, DSUOperationPhase.CREATION, target, propertyKey);
    }
}

/**
 * Metadata passed to {@link DSUEditingHandler}s
 *
 * @typedef DSUEditMetadata
 * @memberOf core.model
 */
export type DSUEditMetadata = {
    [indexer: string]: any;

    operation: string[]
    phase: string,
    key?: string,
    grouped?: boolean,
    grouping?: string
    dsuPath: string
    ,
}

/**
 * Writes the content of the Model property onto the DSU, in the chosen path
 *
 * @param {string} [dsuPath] defines the mount path. defaults to the property key
 *
 * @decorator dsuFile
 *
 * @category Decorators
 */
export function dsuFile(dsuPath?: string) {
    return (target: any, propertyKey: string) => {
        const path = dsuPath || propertyKey;
        const metadata: DSUEditMetadata = {
            phase: DSUOperationPhase.EDITING,
            operation: DBOperations.ALL,
            key: DsuKeys.DSU_FILE,
            grouping: path,
            dsuPath: path
        };

        Reflect.defineMetadata(
            getDSUModelKey(DsuKeys.DSU_FILE),
            metadata,
            target,
            propertyKey
        );

        const editingHandler: DSUEditingHandler = function&lt;T extends DBModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, obj: any, dsu: DSU, decorator: DSUEditMetadata, callback: DSUCallback&lt;T>): void {
            const {value, props} = decorator;
            const {dsuPath} = props;
            if (!value)
                return criticalCallback(`Missing Value to write in ${dsuPath}`, callback)
            dsu.writeFile(dsuPath, JSON.stringify(value), (err: Err) => {
                if (err)
                    return criticalCallback(err, callback);
                callback(undefined, obj, dsu);
            });
        }

        const readHandler: DSUEditingHandler = function&lt;T extends DBModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, obj: {[indexer: string]: any}, dsu: DSU, decorator: DSUEditMetadata, callback: DSUCallback&lt;T>): void {
            const {props, prop} = decorator;
            const {dsuPath, grouped} = props;
            dsu.readFile(dsuPath, (err: Err, data: any) => {
                if (err || !data)
                    return criticalCallback(err || new Error("Missing Data"), callback);
                try {
                    data = JSON.parse(data);
                } catch (e) {
                    return criticalCallback(e as Error, callback);
                }

                if (grouped)
                    Object.entries(data).forEach(([key, value]) => obj[key] = value);
                else
                    obj[prop] = data;

                callback(undefined, obj as T, dsu);
            });
        }

        const deleteHandler: DSUEditingHandler = function&lt;T extends DBModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, obj: T | {}, dsu: DSU, decorator: DSUEditMetadata, callback: DSUCallback&lt;T> | ReadCallback): void {
            const {props} = decorator;
            const {dsuPath} = props;
            dsu.delete(dsuPath, (err) => {
                if (err)
                    return criticalCallback(err, callback);
                callback(undefined, obj as T, dsu);
            });
        }

        getDSUOperationsRegistry().register(readHandler, OperationKeys.READ, DSUOperationPhase.EDITING, target, propertyKey)
        getDSUOperationsRegistry().register(deleteHandler, OperationKeys.DELETE, DSUOperationPhase.EDITING, target, propertyKey)
        DBOperations.CREATE_UPDATE.forEach(p => getDSUOperationsRegistry().register(editingHandler, p, DSUOperationPhase.EDITING, target, propertyKey));
    }
}

/**
 * Mounts the {@link keySSI} in the property value it holds.
 *
 * @param {string} [mountPath] defines the mount path. defaults to the property key
 * @param {boolean | number} [derive]
 * @param {DSUIOOptions} [options]
 * @param {any[]} [args] optional params. meant for extending decorators
 *
 * @decorator mount
 *
 * @category Decorators
 */
export function mount(mountPath?: string, derive: boolean | number = false, options?: DSUIOOptions, ...args: any[]) {
    return (target: any, propertyKey: string) => {
        mountPath = mountPath ? mountPath : propertyKey;
        if (!mountPath)
            throw new CriticalError(`Missing mount path`);

        const metadata: DSUEditMetadata = {
            phase: DSUOperationPhase.EDITING,
            operation: [OperationKeys.READ, OperationKeys.CREATE],
            dsuPath: mountPath,
            derive: derive,
            options: options,
            propKey: propertyKey,
            args: args
        };

        Reflect.defineMetadata(
            getDSUModelKey(DsuKeys.MOUNT),
            metadata,
            target,
            propertyKey
        );

        const createHandler: DSUEditingHandler = function&lt;T extends DBModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, obj: T | {[indexer: string]: any}, dsu: DSU, decorator: DSUEditMetadata, callback: DSUCallback&lt;T> | ReadCallback): void {
            const {dsuPath, options, propKey, derive} = decorator.props;
            if (!decorator.key)
                return criticalCallback(new Error(`Decorator does not hold the property key`), callback);
            let keySSI: string | KeySSI = obj[propKey];
            if (!keySSI)
                return criticalCallback(new Error(`Model does not hold the key under its ${propKey} property but ${obj[propKey]} instead`), callback);

            if (typeof keySSI === 'string')
                try {
                    keySSI = getKeySSIApi().parse(keySSI as string);
                } catch (e) {
                    return criticalCallback(e as Error, callback);
                }

            try {
                keySSI = handleKeyDerivation(keySSI, derive);
            } catch (e) {
                return criticalCallback(e as Error, callback);
            }

            all(`Mounting DSU with KeySSI ${keySSI} under path ${dsuPath}`);
            dsu.mount(dsuPath, keySSI.getIdentifier(), options, err => {
                if (err)
                    return criticalCallback(err, callback);
                all(`Mounting DSU with KeySSI ${keySSI} under path ${dsuPath} Successful`);
                callback(undefined, obj as T, dsu);
            });
        }

        const readHandler: DSUEditingHandler = function&lt;T extends DSUModel>(this: OpenDSURepository&lt;T>, dsuCache: DSUCache&lt;T>, model: T | {}, parentDsu: DSU, decorator: DSUEditMetadata, callback: DSUCallback&lt;T> | ReadCallback){
            const {dsuPath} = decorator.props;
            parentDsu.getSSIForMount(dsuPath, (err, keySSI) => {
                if (err || !keySSI)
                    return criticalCallback(err || new Error('Missing KeySSI'), callback);
                // @ts-ignore
                model[decorator.prop] = keySSI;
                callback(undefined, model as T, parentDsu);
            });
        }

        getDSUOperationsRegistry().register(createHandler, OperationKeys.CREATE,DSUOperationPhase.EDITING,  target, propertyKey);
        getDSUOperationsRegistry().register(readHandler, OperationKeys.READ, DSUOperationPhase.EDITING, target, propertyKey);
    }
}</code></pre>
        </article>
    </section>




            </div>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>

</body>
</html>
